#include "BrainExtractor.h"
#include <algorithm>
#include <cmath>
#include <filesystem>
#include <iomanip>
#include <iostream>
#include <limits>
#include <sstream>

// ITK includes for specific operations
#include "itkBinaryContourImageFilter.h"
#include "itkCastImageFilter.h"
#include "itkImageRegionConstIterator.h"

// Constructor\nBrainExtractor::BrainExtractor() {\n    // Initialize with default parameters\n    m_params = BrainExtractionParams();\n}\n\n// Exception class implementation\nstd::string BrainExtractionException::CreateErrorMessage(ExtractionStatus status, const std::string& details) {\n    std::string base_message;\n    \n    switch (status) {\n        case ExtractionStatus::InputImageInvalid:\n            base_message = \"Input image is invalid or cannot be read\";\n            break;\n        case ExtractionStatus::BiasFieldCorrectionFailed:\n            base_message = \"Bias field correction failed\";\n            break;\n        case ExtractionStatus::ThresholdingFailed:\n            base_message = \"Image thresholding failed\";\n            break;\n        case ExtractionStatus::MorphologyFailed:\n            base_message = \"Morphological operations failed\";\n            break;\n        case ExtractionStatus::NoValidBrainRegion:\n            base_message = \"No valid brain region found\";\n            break;\n        case ExtractionStatus::OutputWriteFailed:\n            base_message = \"Failed to write output file\";\n            break;\n        default:\n            base_message = \"Unknown error occurred\";\n            break;\n    }\n    \n    if (!details.empty()) {\n        base_message += \": \" + details;\n    }\n    \n    return base_message;\n}\n\nBrainExtractionException::BrainExtractionException(ExtractionStatus status, const std::string& details)\n    : m_status(status), m_message(CreateErrorMessage(status, details)) {}\n\nconst char* BrainExtractionException::what() const noexcept {\n    return m_message.c_str();\n}\n\n// Input/Output file management\nvoid BrainExtractor::SetInputFile(const std::string& input) {\n    m_inputFile = input;\n}\n\nvoid BrainExtractor::SetOutputFile(const std::string& output) {\n    m_outputFile = output;\n}\n\n// Parameter management\nvoid BrainExtractor::SetParameters(const BrainExtractionParams& params) {\n    m_params = params;\n}\n\n// Progress reporting\nvoid BrainExtractor::SetProgressCallback(ProgressCallback callback) {\n    m_progressCallback = callback;\n}\n\nvoid BrainExtractor::ReportProgress(float percentage, const std::string& stage) {\n    if (m_progressCallback) {\n        m_progressCallback(percentage, stage);\n    }\n    if (m_params.verbose) {\n        std::cout << \"[\" << std::fixed << std::setprecision(1) << percentage << \"%] \" << stage << std::endl;\n    }\n}\n\n// Main execution function\nExtractionStatus BrainExtractor::Execute() {\n    try {\n        ReportProgress(0.0f, \"Starting brain extraction\");\n        \n        // Step 1: Read input image\n        auto status = ReadInputImage();\n        if (status != ExtractionStatus::Success) return status;\n        ReportProgress(10.0f, \"Input image loaded\");\n        \n        // Step 2: Preprocess image\n        status = PreprocessImage();\n        if (status != ExtractionStatus::Success) return status;\n        ReportProgress(40.0f, \"Image preprocessing completed\");\n        \n        // Step 3: Generate initial mask\n        status = GenerateInitialMask();\n        if (status != ExtractionStatus::Success) return status;\n        ReportProgress(70.0f, \"Initial brain mask generated\");\n        \n        // Step 4: Refine mask\n        status = RefineMask();\n        if (status != ExtractionStatus::Success) return status;\n        ReportProgress(90.0f, \"Brain mask refinement completed\");\n        \n        // Step 5: Save result\n        status = SaveResult();\n        if (status != ExtractionStatus::Success) return status;\n        ReportProgress(100.0f, \"Brain extraction completed successfully\");\n        \n        return ExtractionStatus::Success;\n        \n    } catch (const itk::ExceptionObject& e) {\n        std::cerr << \"ITK Exception: \" << e.what() << std::endl;\n        return ExtractionStatus::InputImageInvalid;\n    } catch (const std::exception& e) {\n        std::cerr << \"Exception: \" << e.what() << std::endl;\n        return ExtractionStatus::InputImageInvalid;\n    }\n}\n\n// Read input image\nExtractionStatus BrainExtractor::ReadInputImage() {\n    try {\n        using ReaderType = itk::ImageFileReader<ImageType>;\n        auto reader = ReaderType::New();\n        reader->SetFileName(m_inputFile);\n        reader->Update();\n        m_inputImage = reader->GetOutput();\n        \n        // Basic validation\n        if (!m_inputImage) {\n            throw BrainExtractionException(ExtractionStatus::InputImageInvalid, \"Image pointer is null\");\n        }\n        \n        // Check if image has reasonable dimensions\n        auto size = m_inputImage->GetLargestPossibleRegion().GetSize();\n        if (size[0] < 50 || size[1] < 50 || size[2] < 50) {\n            throw BrainExtractionException(ExtractionStatus::InputImageInvalid, \"Image dimensions too small\");\n        }\n        \n        return ExtractionStatus::Success;\n        \n    } catch (const itk::ExceptionObject& e) {\n        throw BrainExtractionException(ExtractionStatus::InputImageInvalid, e.GetDescription());\n    }\n}\n\n// Preprocess image\nExtractionStatus BrainExtractor::PreprocessImage() {\n    m_preprocessedImage = m_inputImage;\n    \n    // Step 1: Bias field correction\n    if (m_params.enable_bias_correction) {\n        auto status = ApplyBiasFieldCorrection();\n        if (status != ExtractionStatus::Success) return status;\n    }\n    \n    // Step 2: Noise reduction\n    auto status = ApplyNoiseReduction();\n    if (status != ExtractionStatus::Success) return status;\n    \n    // Step 3: Intensity normalization\n    status = NormalizeIntensity();\n    if (status != ExtractionStatus::Success) return status;\n    \n    // Save intermediate result if requested\n    if (m_params.save_intermediate_results) {\n        SaveIntermediateResult(m_preprocessedImage, \"preprocessed\");\n    }\n    \n    return ExtractionStatus::Success;\n}\n\n// Apply bias field correction\nExtractionStatus BrainExtractor::ApplyBiasFieldCorrection() {\n    try {\n        using BiasFilterType = itk::N4BiasFieldCorrectionImageFilter<ImageType, MaskType, ImageType>;\n        auto biasFilter = BiasFilterType::New();\n        \n        biasFilter->SetInput(m_preprocessedImage);\n        biasFilter->SetNumberOfFittingLevels(4);\n        biasFilter->SetNumberOfControlPoints(4);\n        biasFilter->SetMaximumNumberOfIterations(std::vector<unsigned int>(4, 50));\n        biasFilter->SetConvergenceThreshold(0.001);\n        \n        biasFilter->Update();\n        m_preprocessedImage = biasFilter->GetOutput();\n        \n        return ExtractionStatus::Success;\n        \n    } catch (const itk::ExceptionObject& e) {\n        throw BrainExtractionException(ExtractionStatus::BiasFieldCorrectionFailed, e.GetDescription());\n    }\n}\n\n// Apply noise reduction\nExtractionStatus BrainExtractor::ApplyNoiseReduction() {\n    try {\n        using GaussianFilterType = itk::DiscreteGaussianImageFilter<ImageType, ImageType>;\n        auto gaussianFilter = GaussianFilterType::New();\n        \n        gaussianFilter->SetInput(m_preprocessedImage);\n        gaussianFilter->SetVariance(m_params.gaussian_sigma * m_params.gaussian_sigma);\n        gaussianFilter->SetMaximumKernelWidth(7);\n        gaussianFilter->Update();\n        \n        m_preprocessedImage = gaussianFilter->GetOutput();\n        \n        return ExtractionStatus::Success;\n        \n    } catch (const itk::ExceptionObject& e) {\n        throw BrainExtractionException(ExtractionStatus::ThresholdingFailed, e.GetDescription());\n    }\n}\n\n// Normalize intensity\nExtractionStatus BrainExtractor::NormalizeIntensity() {\n    try {\n        using RescaleFilterType = itk::RescaleIntensityImageFilter<ImageType, ImageType>;\n        auto rescaleFilter = RescaleFilterType::New();\n        \n        rescaleFilter->SetInput(m_preprocessedImage);\n        rescaleFilter->SetOutputMinimum(0.0);\n        rescaleFilter->SetOutputMaximum(1000.0);\n        rescaleFilter->Update();\n        \n        m_preprocessedImage = rescaleFilter->GetOutput();\n        \n        return ExtractionStatus::Success;\n        \n    } catch (const itk::ExceptionObject& e) {\n        throw BrainExtractionException(ExtractionStatus::ThresholdingFailed, e.GetDescription());\n    }\n}\n\n// Generate initial mask\nExtractionStatus BrainExtractor::GenerateInitialMask() {\n    if (m_params.adaptive_thresholding) {\n        return ApplyAdaptiveThresholding();\n    } else {\n        // Fallback to simple Otsu thresholding\n        try {\n            using OtsuFilterType = itk::OtsuThresholdImageFilter<ImageType, MaskType>;\n            auto otsuFilter = OtsuFilterType::New();\n            otsuFilter->SetInput(m_preprocessedImage);\n            otsuFilter->SetInsideValue(1);\n            otsuFilter->SetOutsideValue(0);\n            otsuFilter->Update();\n            \n            m_rawMask = otsuFilter->GetOutput();\n            return ExtractionStatus::Success;\n            \n        } catch (const itk::ExceptionObject& e) {\n            throw BrainExtractionException(ExtractionStatus::ThresholdingFailed, e.GetDescription());\n        }\n    }\n}\n\n// Apply adaptive thresholding\nExtractionStatus BrainExtractor::ApplyAdaptiveThresholding() {\n    try {\n        float threshold = CalculateOptimalThreshold();\n        \n        using ThresholdFilterType = itk::BinaryThresholdImageFilter<ImageType, MaskType>;\n        auto thresholdFilter = ThresholdFilterType::New();\n        \n        thresholdFilter->SetInput(m_preprocessedImage);\n        thresholdFilter->SetLowerThreshold(threshold);\n        thresholdFilter->SetUpperThreshold(1000.0f);  // Max intensity\n        thresholdFilter->SetInsideValue(1);\n        thresholdFilter->SetOutsideValue(0);\n        thresholdFilter->Update();\n        \n        m_rawMask = thresholdFilter->GetOutput();\n        \n        if (m_params.save_intermediate_results) {\n            SaveIntermediateResult(m_rawMask, \"raw_mask\");\n        }\n        \n        return ExtractionStatus::Success;\n        \n    } catch (const itk::ExceptionObject& e) {\n        throw BrainExtractionException(ExtractionStatus::ThresholdingFailed, e.GetDescription());\n    }\n}\n\n// Calculate optimal threshold\nfloat BrainExtractor::CalculateOptimalThreshold() {\n    using StatisticsFilterType = itk::StatisticsImageFilter<ImageType>;\n    auto statsFilter = StatisticsFilterType::New();\n    statsFilter->SetInput(m_preprocessedImage);\n    statsFilter->Update();\n    \n    float minValue = statsFilter->GetMinimum();\n    float maxValue = statsFilter->GetMaximum();\n    \n    // Simple percentile-based thresholding\n    // This is a simplified version - in practice, you'd want histogram analysis\n    float backgroundThreshold = minValue + (maxValue - minValue) * m_params.intensity_percentile;\n    float brainThreshold = minValue + (maxValue - minValue) * m_params.brain_percentile;\n    \n    // Use the midpoint between background and brain tissue\n    return (backgroundThreshold + brainThreshold) / 2.0f;\n}\n\n// Refine mask using morphological operations\nExtractionStatus BrainExtractor::RefineMask() {\n    m_finalMask = m_rawMask;\n    \n    // Step 1: Morphological operations\n    auto status = ApplyMorphologicalOperations();\n    if (status != ExtractionStatus::Success) return status;\n    \n    // Step 2: Extract largest component\n    status = ExtractLargestComponent();\n    if (status != ExtractionStatus::Success) return status;\n    \n    // Step 3: Fill holes\n    if (m_params.fill_holes) {\n        status = FillHoles();\n        if (status != ExtractionStatus::Success) return status;\n    }\n    \n    // Step 4: Smooth boundaries\n    if (m_params.enable_smoothing) {\n        status = SmoothBoundaries();\n        if (status != ExtractionStatus::Success) return status;\n    }\n    \n    return ExtractionStatus::Success;\n}\n\n// Apply morphological operations\nExtractionStatus BrainExtractor::ApplyMorphologicalOperations() {\n    try {\n        // Opening operation (erosion followed by dilation)\n        using OpeningFilterType = itk::BinaryMorphologicalOpeningImageFilter<MaskType, MaskType, BallStructuringElementType>;\n        auto openingFilter = OpeningFilterType::New();\n        \n        auto openingKernel = CreateStructuringElement(m_params.opening_radius);\n        openingFilter->SetInput(m_finalMask);\n        openingFilter->SetKernel(openingKernel);\n        openingFilter->SetForegroundValue(1);\n        openingFilter->Update();\n        \n        m_finalMask = openingFilter->GetOutput();\n        \n        // Closing operation (dilation followed by erosion)\n        using ClosingFilterType = itk::BinaryMorphologicalClosingImageFilter<MaskType, MaskType, BallStructuringElementType>;\n        auto closingFilter = ClosingFilterType::New();\n        \n        auto closingKernel = CreateStructuringElement(m_params.closing_radius);\n        closingFilter->SetInput(m_finalMask);\n        closingFilter->SetKernel(closingKernel);\n        closingFilter->SetForegroundValue(1);\n        closingFilter->Update();\n        \n        m_finalMask = closingFilter->GetOutput();\n        \n        return ExtractionStatus::Success;\n        \n    } catch (const itk::ExceptionObject& e) {\n        throw BrainExtractionException(ExtractionStatus::MorphologyFailed, e.GetDescription());\n    }\n}\n\n// Extract largest connected component\nExtractionStatus BrainExtractor::ExtractLargestComponent() {\n    try {\n        using ConnectedComponentFilterType = itk::ConnectedComponentImageFilter<MaskType, MaskType>;\n        auto connectedComponents = ConnectedComponentFilterType::New();\n        connectedComponents->SetInput(m_finalMask);\n        \n        using KeepLargestFilterType = itk::LabelShapeKeepNObjectsImageFilter<MaskType>;\n        auto keepLargestFilter = KeepLargestFilterType::New();\n        keepLargestFilter->SetInput(connectedComponents->GetOutput());\n        keepLargestFilter->SetNumberOfObjects(1);\n        keepLargestFilter->SetAttribute(KeepLargestFilterType::LabelObjectType::NUMBER_OF_PIXELS);\n        \n        using BinaryFilterType = itk::BinaryThresholdImageFilter<MaskType, MaskType>;\n        auto binaryFilter = BinaryFilterType::New();\n        binaryFilter->SetInput(keepLargestFilter->GetOutput());\n        binaryFilter->SetLowerThreshold(1);\n        binaryFilter->SetUpperThreshold(std::numeric_limits<MaskType::PixelType>::max());\n        binaryFilter->SetInsideValue(1);\n        binaryFilter->SetOutsideValue(0);\n        binaryFilter->Update();\n        \n        m_finalMask = binaryFilter->GetOutput();\n        \n        // Validate that we have a reasonable brain region\n        using StatisticsFilterType = itk::StatisticsImageFilter<MaskType>;\n        auto statsFilter = StatisticsFilterType::New();\n        statsFilter->SetInput(m_finalMask);\n        statsFilter->Update();\n        \n        if (statsFilter->GetSum() < 1000) {  // Less than 1000 voxels\n            throw BrainExtractionException(ExtractionStatus::NoValidBrainRegion, \"Extracted region too small\");\n        }\n        \n        return ExtractionStatus::Success;\n        \n    } catch (const itk::ExceptionObject& e) {\n        throw BrainExtractionException(ExtractionStatus::MorphologyFailed, e.GetDescription());\n    }\n}\n\n// Fill holes in the mask\nExtractionStatus BrainExtractor::FillHoles() {\n    try {\n        using FillHoleFilterType = itk::BinaryFillholeImageFilter<MaskType>;\n        auto fillHoleFilter = FillHoleFilterType::New();\n        fillHoleFilter->SetInput(m_finalMask);\n        fillHoleFilter->SetForegroundValue(1);\n        fillHoleFilter->Update();\n        \n        m_finalMask = fillHoleFilter->GetOutput();\n        \n        return ExtractionStatus::Success;\n        \n    } catch (const itk::ExceptionObject& e) {\n        throw BrainExtractionException(ExtractionStatus::MorphologyFailed, e.GetDescription());\n    }\n}\n\n// Smooth boundaries\nExtractionStatus BrainExtractor::SmoothBoundaries() {\n    try {\n        using SmoothingFilterType = itk::AntiAliasBinaryImageFilter<MaskType, ImageType>;\n        auto smoothingFilter = SmoothingFilterType::New();\n        \n        smoothingFilter->SetInput(m_finalMask);\n        smoothingFilter->SetMaximumRMSError(m_params.smoothing_tolerance);\n        smoothingFilter->SetNumberOfIterations(m_params.smoothing_iterations);\n        smoothingFilter->Update();\n        \n        // Convert back to binary mask\n        using ThresholdFilterType = itk::BinaryThresholdImageFilter<ImageType, MaskType>;\n        auto thresholdFilter = ThresholdFilterType::New();\n        thresholdFilter->SetInput(smoothingFilter->GetOutput());\n        thresholdFilter->SetLowerThreshold(0.5);\n        thresholdFilter->SetUpperThreshold(std::numeric_limits<float>::max());\n        thresholdFilter->SetInsideValue(1);\n        thresholdFilter->SetOutsideValue(0);\n        thresholdFilter->Update();\n        \n        m_finalMask = thresholdFilter->GetOutput();\n        \n        return ExtractionStatus::Success;\n        \n    } catch (const itk::ExceptionObject& e) {\n        throw BrainExtractionException(ExtractionStatus::MorphologyFailed, e.GetDescription());\n    }\n}\n\n// Save result\nExtractionStatus BrainExtractor::SaveResult() {\n    try {\n        using WriterType = itk::ImageFileWriter<MaskType>;\n        auto writer = WriterType::New();\n        writer->SetFileName(m_outputFile);\n        writer->SetInput(m_finalMask);\n        writer->Update();\n        \n        return ExtractionStatus::Success;\n        \n    } catch (const itk::ExceptionObject& e) {\n        throw BrainExtractionException(ExtractionStatus::OutputWriteFailed, e.GetDescription());\n    }\n}\n\n// Create structuring element\nBrainExtractor::BallStructuringElementType BrainExtractor::CreateStructuringElement(float radius_mm) {\n    BallStructuringElementType structuringElement;\n    \n    // Convert radius from mm to voxels\n    auto spacing = m_finalMask->GetSpacing();\n    BallStructuringElementType::SizeType radius;\n    \n    for (unsigned int i = 0; i < 3; ++i) {\n        radius[i] = static_cast<unsigned int>(std::max(1.0, radius_mm / spacing[i]));\n    }\n    \n    structuringElement.SetRadius(radius);\n    structuringElement.CreateStructuringElement();\n    \n    return structuringElement;\n}\n\n// Save intermediate results\nvoid BrainExtractor::SaveIntermediateResult(ImageType::Pointer image, const std::string& suffix) {\n    if (!std::filesystem::exists(m_params.debug_output_dir)) {\n        std::filesystem::create_directories(m_params.debug_output_dir);\n    }\n    \n    std::string filename = m_params.debug_output_dir + \"/intermediate_\" + suffix + \".nii.gz\";\n    \n    try {\n        using WriterType = itk::ImageFileWriter<ImageType>;\n        auto writer = WriterType::New();\n        writer->SetFileName(filename);\n        writer->SetInput(image);\n        writer->Update();\n    } catch (const itk::ExceptionObject& e) {\n        std::cerr << \"Warning: Could not save intermediate result: \" << e.what() << std::endl;\n    }\n}\n\nvoid BrainExtractor::SaveIntermediateResult(MaskType::Pointer mask, const std::string& suffix) {\n    if (!std::filesystem::exists(m_params.debug_output_dir)) {\n        std::filesystem::create_directories(m_params.debug_output_dir);\n    }\n    \n    std::string filename = m_params.debug_output_dir + \"/intermediate_\" + suffix + \".nii.gz\";\n    \n    try {\n        using WriterType = itk::ImageFileWriter<MaskType>;\n        auto writer = WriterType::New();\n        writer->SetFileName(filename);\n        writer->SetInput(mask);\n        writer->Update();\n    } catch (const itk::ExceptionObject& e) {\n        std::cerr << \"Warning: Could not save intermediate result: \" << e.what() << std::endl;\n    }\n}\n\n// Validation functions\nValidationMetrics BrainExtractor::ValidateResult(const std::string& ground_truth_file) {\n    try {\n        using ReaderType = itk::ImageFileReader<MaskType>;\n        auto reader = ReaderType::New();\n        reader->SetFileName(ground_truth_file);\n        reader->Update();\n        auto groundTruth = reader->GetOutput();\n        \n        return CalculateValidationMetrics(m_finalMask, groundTruth);\n        \n    } catch (const itk::ExceptionObject& e) {\n        ValidationMetrics metrics;\n        metrics.is_valid = false;\n        return metrics;\n    }\n}\n\nValidationMetrics BrainExtractor::CalculateValidationMetrics(MaskType::Pointer result, MaskType::Pointer reference) {\n    ValidationMetrics metrics;\n    \n    try {\n        itk::ImageRegionIterator<MaskType> resultIt(result, result->GetLargestPossibleRegion());\n        itk::ImageRegionIterator<MaskType> refIt(reference, reference->GetLargestPossibleRegion());\n        \n        unsigned int truePositive = 0, falsePositive = 0, falseNegative = 0, trueNegative = 0;\n        \n        for (resultIt.GoToBegin(), refIt.GoToBegin(); !resultIt.IsAtEnd(); ++resultIt, ++refIt) {\n            bool resultPos = (resultIt.Get() > 0);\n            bool refPos = (refIt.Get() > 0);\n            \n            if (resultPos && refPos) truePositive++;\n            else if (resultPos && !refPos) falsePositive++;\n            else if (!resultPos && refPos) falseNegative++;\n            else trueNegative++;\n        }\n        \n        // Calculate metrics\n        float intersection = truePositive;\n        float union_size = truePositive + falsePositive + falseNegative;\n        float result_size = truePositive + falsePositive;\n        float ref_size = truePositive + falseNegative;\n        \n        if (union_size > 0) {\n            metrics.dice_coefficient = (2.0f * intersection) / (result_size + ref_size);\n            metrics.jaccard_index = intersection / union_size;\n        }\n        \n        if (ref_size > 0) {\n            metrics.volume_ratio = result_size / ref_size;\n        }\n        \n        metrics.is_valid = true;\n        \n    } catch (const std::exception& e) {\n        metrics.is_valid = false;\n    }\n    \n    return metrics;\n}\n\n// Comprehensive validation\nComprehensiveValidationMetrics BrainExtractor::ValidateResultComprehensive(const std::string& ground_truth_file) {\n    try {\n        using ReaderType = itk::ImageFileReader<MaskType>;\n        auto reader = ReaderType::New();\n        reader->SetFileName(ground_truth_file);\n        reader->Update();\n        auto groundTruth = reader->GetOutput();\n        \n        return CalculateComprehensiveMetrics(m_finalMask, groundTruth);\n        \n    } catch (const itk::ExceptionObject& e) {\n        ComprehensiveValidationMetrics metrics;\n        metrics.is_valid = false;\n        return metrics;\n    }\n}\n\nComprehensiveValidationMetrics BrainExtractor::CalculateComprehensiveMetrics(MaskType::Pointer result, MaskType::Pointer reference) {\n    ComprehensiveValidationMetrics metrics;\n    \n    try {\n        auto start_time = std::chrono::high_resolution_clock::now();\n        \n        // Calculate individual metric components\n        metrics.overlap = CalculateOverlapMetrics(result, reference);\n        metrics.boundary = CalculateBoundaryMetrics(result, reference);\n        metrics.volumetric = CalculateVolumetricMetrics(result, reference);\n        metrics.morphology = CalculateMorphologyMetrics(result);\n        metrics.robustness = CalculateRobustnessMetrics(result, reference);\n        \n        // Calculate overall quality and clinical grade\n        metrics.CalculateOverallQuality();\n        metrics.clinical = CalculateClinicalMetrics(metrics);\n        metrics.AssessClinicalGrade();\n        \n        // Set metadata\n        auto now = std::chrono::system_clock::now();\n        auto time_t = std::chrono::system_clock::to_time_t(now);\n        auto tm = *std::localtime(&time_t);\n        std::stringstream ss;\n        ss << std::put_time(&tm, \"%Y-%m-%d %H:%M:%S\");\n        metrics.validation_timestamp = ss.str();\n        metrics.algorithm_version = \"BET-Lite v2.0\";\n        \n        auto end_time = std::chrono::high_resolution_clock::now();\n        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end_time - start_time);\n        metrics.clinical.processing_time_seconds = duration.count() / 1000.0f;\n        \n        metrics.is_valid = true;\n        \n    } catch (const std::exception& e) {\n        metrics.is_valid = false;\n        std::cerr << \"Error calculating comprehensive metrics: \" << e.what() << std::endl;\n    }\n    \n    return metrics;\n}\n\nOverlapMetrics BrainExtractor::CalculateOverlapMetrics(MaskType::Pointer result, MaskType::Pointer reference) {\n    OverlapMetrics metrics;\n    \n    try {\n        itk::ImageRegionConstIterator<MaskType> resultIt(result, result->GetLargestPossibleRegion());\n        itk::ImageRegionConstIterator<MaskType> refIt(reference, reference->GetLargestPossibleRegion());\n        \n        unsigned int TP = 0, FP = 0, FN = 0, TN = 0;\n        \n        for (resultIt.GoToBegin(), refIt.GoToBegin(); !resultIt.IsAtEnd(); ++resultIt, ++refIt) {\n            bool resultPos = (resultIt.Get() > 0);\n            bool refPos = (refIt.Get() > 0);\n            \n            if (resultPos && refPos) TP++;\n            else if (resultPos && !refPos) FP++;\n            else if (!resultPos && refPos) FN++;\n            else TN++;\n        }\n        \n        // Calculate all overlap metrics\n        float total = TP + FP + FN + TN;\n        float intersection = TP;\n        float union_size = TP + FP + FN;\n        float result_size = TP + FP;\n        float ref_size = TP + FN;\n        \n        if (union_size > 0) {\n            metrics.dice_coefficient = (2.0f * intersection) / (result_size + ref_size);\n            metrics.jaccard_index = intersection / union_size;\n        }\n        \n        if (ref_size > 0) {\n            metrics.sensitivity = static_cast<float>(TP) / ref_size;  // TPR\n        }\n        \n        if ((TN + FP) > 0) {\n            metrics.specificity = static_cast<float>(TN) / (TN + FP);  // TNR\n        }\n        \n        if (result_size > 0) {\n            metrics.precision = static_cast<float>(TP) / result_size;  // PPV\n        }\n        \n        if ((TN + FN) > 0) {\n            metrics.negative_predictive_value = static_cast<float>(TN) / (TN + FN);  // NPV\n        }\n        \n        if (total > 0) {\n            metrics.accuracy = static_cast<float>(TP + TN) / total;\n        }\n        \n        // F1 Score\n        if (metrics.precision + metrics.sensitivity > 0) {\n            metrics.f1_score = 2.0f * (metrics.precision * metrics.sensitivity) / (metrics.precision + metrics.sensitivity);\n        }\n        \n    } catch (const std::exception& e) {\n        std::cerr << \"Error calculating overlap metrics: \" << e.what() << std::endl;\n    }\n    \n    return metrics;\n}\n\nBoundaryMetrics BrainExtractor::CalculateBoundaryMetrics(MaskType::Pointer result, MaskType::Pointer reference) {\n    BoundaryMetrics metrics;\n    \n    try {\n        // Extract boundaries using contour filter\n        using ContourFilterType = itk::BinaryContourImageFilter<MaskType, MaskType>;\n        \n        auto resultContour = ContourFilterType::New();\n        resultContour->SetInput(result);\n        resultContour->SetForegroundValue(1);\n        resultContour->SetBackgroundValue(0);\n        resultContour->Update();\n        \n        auto refContour = ContourFilterType::New();\n        refContour->SetInput(reference);\n        refContour->SetForegroundValue(1);\n        refContour->SetBackgroundValue(0);\n        refContour->Update();\n        \n        // Calculate distance maps\n        using DistanceFilterType = itk::SignedMaurerDistanceMapImageFilter<MaskType, ImageType>;\n        \n        auto resultDistanceFilter = DistanceFilterType::New();\n        resultDistanceFilter->SetInput(result);\n        resultDistanceFilter->SetSquaredDistance(false);\n        resultDistanceFilter->SetUseImageSpacing(true);\n        resultDistanceFilter->SetInsideIsPositive(false);\n        resultDistanceFilter->Update();\n        \n        auto refDistanceFilter = DistanceFilterType::New();\n        refDistanceFilter->SetInput(reference);\n        refDistanceFilter->SetSquaredDistance(false);\n        refDistanceFilter->SetUseImageSpacing(true);\n        refDistanceFilter->SetInsideIsPositive(false);\n        refDistanceFilter->Update();\n        \n        // Sample distances at boundary points\n        std::vector<float> distances_result_to_ref;\n        std::vector<float> distances_ref_to_result;\n        \n        // Sample result boundary distances to reference\n        itk::ImageRegionConstIterator<MaskType> resultBoundaryIt(resultContour->GetOutput(), \n                                                                  resultContour->GetOutput()->GetLargestPossibleRegion());\n        itk::ImageRegionConstIterator<ImageType> refDistanceIt(refDistanceFilter->GetOutput(), \n                                                               refDistanceFilter->GetOutput()->GetLargestPossibleRegion());\n        \n        for (resultBoundaryIt.GoToBegin(), refDistanceIt.GoToBegin(); \n             !resultBoundaryIt.IsAtEnd(); \n             ++resultBoundaryIt, ++refDistanceIt) {\n            if (resultBoundaryIt.Get() > 0) {  // On result boundary\n                distances_result_to_ref.push_back(std::abs(refDistanceIt.Get()));\n            }\n        }\n        \n        // Sample reference boundary distances to result\n        itk::ImageRegionConstIterator<MaskType> refBoundaryIt(refContour->GetOutput(), \n                                                              refContour->GetOutput()->GetLargestPossibleRegion());\n        itk::ImageRegionConstIterator<ImageType> resultDistanceIt(resultDistanceFilter->GetOutput(), \n                                                                  resultDistanceFilter->GetOutput()->GetLargestPossibleRegion());\n        \n        for (refBoundaryIt.GoToBegin(), resultDistanceIt.GoToBegin(); \n             !refBoundaryIt.IsAtEnd(); \n             ++refBoundaryIt, ++resultDistanceIt) {\n            if (refBoundaryIt.Get() > 0) {  // On reference boundary\n                distances_ref_to_result.push_back(std::abs(resultDistanceIt.Get()));\n            }\n        }\n        \n        // Combine all distances for statistics\n        std::vector<float> all_distances;\n        all_distances.insert(all_distances.end(), distances_result_to_ref.begin(), distances_result_to_ref.end());\n        all_distances.insert(all_distances.end(), distances_ref_to_result.begin(), distances_ref_to_result.end());\n        \n        if (!all_distances.empty()) {\n            // Sort for percentile calculations\n            std::sort(all_distances.begin(), all_distances.end());\n            \n            // Calculate metrics\n            metrics.hausdorff_distance = *std::max_element(all_distances.begin(), all_distances.end());\n            \n            size_t idx_95 = static_cast<size_t>(0.95 * all_distances.size());\n            if (idx_95 < all_distances.size()) {\n                metrics.hausdorff_95_percentile = all_distances[idx_95];\n            }\n            \n            // Average surface distance\n            float sum = std::accumulate(all_distances.begin(), all_distances.end(), 0.0f);\n            metrics.average_surface_distance = sum / all_distances.size();\n            \n            // RMS surface distance\n            float sum_squares = 0.0f;\n            for (float d : all_distances) {\n                sum_squares += d * d;\n            }\n            metrics.rms_surface_distance = std::sqrt(sum_squares / all_distances.size());\n            \n            // Surface distance statistics\n            metrics.surface_stats.mean = metrics.average_surface_distance;\n            \n            // Standard deviation\n            float sum_squared_diffs = 0.0f;\n            for (float d : all_distances) {\n                float diff = d - metrics.surface_stats.mean;\n                sum_squared_diffs += diff * diff;\n            }\n            metrics.surface_stats.std_dev = std::sqrt(sum_squared_diffs / all_distances.size());\n            \n            // Percentiles\n            size_t idx_5 = static_cast<size_t>(0.05 * all_distances.size());\n            size_t idx_50 = static_cast<size_t>(0.50 * all_distances.size());\n            \n            if (idx_5 < all_distances.size()) {\n                metrics.surface_stats.percentile_5 = all_distances[idx_5];\n            }\n            if (idx_50 < all_distances.size()) {\n                metrics.surface_stats.median = all_distances[idx_50];\n            }\n            \n            metrics.surface_stats.percentile_95 = metrics.hausdorff_95_percentile;\n            metrics.surface_stats.max_distance = metrics.hausdorff_distance;\n        }\n        \n    } catch (const std::exception& e) {\n        std::cerr << \"Error calculating boundary metrics: \" << e.what() << std::endl;\n    }\n    \n    return metrics;\n}\n\nVolumetricMetrics BrainExtractor::CalculateVolumetricMetrics(MaskType::Pointer result, MaskType::Pointer reference) {\n    VolumetricMetrics metrics;\n    \n    try {\n        using StatisticsFilterType = itk::StatisticsImageFilter<MaskType>;\n        \n        auto resultStats = StatisticsFilterType::New();\n        resultStats->SetInput(result);\n        resultStats->Update();\n        \n        auto refStats = StatisticsFilterType::New();\n        refStats->SetInput(reference);\n        refStats->Update();\n        \n        // Get voxel volume in mm³\n        auto spacing = result->GetSpacing();\n        float voxel_volume_mm3 = spacing[0] * spacing[1] * spacing[2];\n        \n        // Volume calculations\n        unsigned long result_voxels = static_cast<unsigned long>(resultStats->GetSum());\n        unsigned long ref_voxels = static_cast<unsigned long>(refStats->GetSum());\n        \n        metrics.predicted_volume_ml = (result_voxels * voxel_volume_mm3) / 1000.0f;  // mm³ to ml\n        metrics.reference_volume_ml = (ref_voxels * voxel_volume_mm3) / 1000.0f;\n        \n        if (metrics.reference_volume_ml > 0) {\n            metrics.volume_ratio = metrics.predicted_volume_ml / metrics.reference_volume_ml;\n            metrics.relative_volume_error = ((metrics.predicted_volume_ml - metrics.reference_volume_ml) / \n                                            metrics.reference_volume_ml) * 100.0f;\n        }\n        \n        metrics.absolute_volume_difference = std::abs(metrics.predicted_volume_ml - metrics.reference_volume_ml);\n        \n        // Volume similarity\n        if ((metrics.predicted_volume_ml + metrics.reference_volume_ml) > 0) {\n            metrics.volume_similarity = 1.0f - (metrics.absolute_volume_difference / \n                                               (metrics.predicted_volume_ml + metrics.reference_volume_ml));\n        }\n        \n        // Volume correlation (would need multiple cases for meaningful correlation)\n        metrics.volume_correlation = 1.0f;  // Perfect correlation for single case\n        \n    } catch (const std::exception& e) {\n        std::cerr << \"Error calculating volumetric metrics: \" << e.what() << std::endl;\n    }\n    \n    return metrics;\n}\n\nMorphologyMetrics BrainExtractor::CalculateMorphologyMetrics(MaskType::Pointer mask) {\n    MorphologyMetrics metrics;\n    \n    try {\n        // Connected components analysis\n        using ConnectedComponentFilterType = itk::ConnectedComponentImageFilter<MaskType, MaskType>;\n        auto connectedFilter = ConnectedComponentFilterType::New();\n        connectedFilter->SetInput(mask);\n        connectedFilter->Update();\n        \n        using LabelStatisticsFilterType = itk::LabelStatisticsImageFilter<MaskType, MaskType>;\n        auto labelStats = LabelStatisticsFilterType::New();\n        labelStats->SetLabelInput(connectedFilter->GetOutput());\n        labelStats->SetInput(mask);\n        labelStats->Update();\n        \n        metrics.num_connected_components = labelStats->GetNumberOfLabels() - 1;  // Exclude background\n        metrics.is_single_component = (metrics.num_connected_components == 1);\n        \n        // Find component sizes\n        unsigned long largest_component_size = 0;\n        unsigned long total_size = 0;\n        \n        for (auto label : labelStats->GetLabels()) {\n            if (label != 0) {  // Skip background\n                unsigned long size = labelStats->GetCount(label);\n                metrics.component_sizes.push_back(static_cast<int>(size));\n                total_size += size;\n                if (size > largest_component_size) {\n                    largest_component_size = size;\n                }\n            }\n        }\n        \n        if (total_size > 0) {\n            metrics.largest_component_ratio = static_cast<float>(largest_component_size) / total_size;\n        }\n        \n        // Volume and surface area calculations\n        auto spacing = mask->GetSpacing();\n        float voxel_volume = spacing[0] * spacing[1] * spacing[2];\n        \n        using StatisticsFilterType = itk::StatisticsImageFilter<MaskType>;\n        auto stats = StatisticsFilterType::New();\n        stats->SetInput(mask);\n        stats->Update();\n        \n        float volume_mm3 = stats->GetSum() * voxel_volume;\n        \n        // Approximate surface area using boundary voxels\n        using ContourFilterType = itk::BinaryContourImageFilter<MaskType, MaskType>;\n        auto contourFilter = ContourFilterType::New();\n        contourFilter->SetInput(mask);\n        contourFilter->SetForegroundValue(1);\n        contourFilter->Update();\n        \n        auto boundaryStats = StatisticsFilterType::New();\n        boundaryStats->SetInput(contourFilter->GetOutput());\n        boundaryStats->Update();\n        \n        // Approximate surface area (rough estimate)\n        float voxel_face_area = std::min({spacing[0] * spacing[1], spacing[1] * spacing[2], spacing[0] * spacing[2]});\n        metrics.surface_area_mm2 = boundaryStats->GetSum() * voxel_face_area * 6.0f;  // 6 faces per voxel\n        \n        // Compactness (isoperimetric ratio)\n        if (metrics.surface_area_mm2 > 0) {\n            float ideal_surface_area = std::pow(36.0f * M_PI * volume_mm3 * volume_mm3, 1.0f/3.0f);\n            metrics.compactness = ideal_surface_area / metrics.surface_area_mm2;\n        }\n        \n        // Sphericity\n        if (metrics.surface_area_mm2 > 0) {\n            float sphere_surface_area = std::pow(M_PI, 1.0f/3.0f) * std::pow(6.0f * volume_mm3, 2.0f/3.0f);\n            metrics.sphericity = sphere_surface_area / metrics.surface_area_mm2;\n        }\n        \n        // Surface smoothness (simplified - based on boundary regularity)\n        metrics.surface_smoothness = std::min(1.0f, metrics.sphericity);  // Placeholder\n        \n    } catch (const std::exception& e) {\n        std::cerr << \"Error calculating morphology metrics: \" << e.what() << std::endl;\n    }\n    \n    return metrics;\n}\n\nRobustnessMetrics BrainExtractor::CalculateRobustnessMetrics(MaskType::Pointer result, MaskType::Pointer reference) {\n    RobustnessMetrics metrics;\n    \n    try {\n        // Calculate basic overlap for failure mode detection\n        auto overlap = CalculateOverlapMetrics(result, reference);\n        auto morphology = CalculateMorphologyMetrics(result);\n        \n        // Detect failure modes\n        if (overlap.dice_coefficient < 0.7f) {\n            if (overlap.sensitivity < 0.8f) {\n                metrics.primary_failure = RobustnessMetrics::FailureMode::UnderSegmentation;\n            } else if (overlap.specificity < 0.8f) {\n                metrics.primary_failure = RobustnessMetrics::FailureMode::OverSegmentation;\n            }\n        }\n        \n        if (!morphology.is_single_component && morphology.num_connected_components > 3) {\n            metrics.primary_failure = RobustnessMetrics::FailureMode::Fragmentation;\n        }\n        \n        // Topology error detection (simplified)\n        metrics.has_topology_errors = (morphology.num_connected_components > 2);\n        \n        // Confidence score based on multiple factors\n        float dice_confidence = overlap.dice_coefficient;\n        float morphology_confidence = morphology.is_single_component ? 1.0f : 0.5f;\n        float volume_confidence = std::max(0.0f, 1.0f - std::abs(overlap.dice_coefficient - 0.9f) / 0.1f);\n        \n        metrics.confidence_score = (dice_confidence + morphology_confidence + volume_confidence) / 3.0f;\n        \n        // Stability score (would require multiple runs with parameter variations)\n        metrics.stability_score = metrics.confidence_score;  // Placeholder\n        \n        // Parameter sensitivity (placeholder)\n        metrics.parameter_sensitivity = 0.5f;\n        \n    } catch (const std::exception& e) {\n        std::cerr << \"Error calculating robustness metrics: \" << e.what() << std::endl;\n    }\n    \n    return metrics;\n}\n\nClinicalMetrics BrainExtractor::CalculateClinicalMetrics(const ComprehensiveValidationMetrics& metrics) {\n    ClinicalMetrics clinical;\n    \n    // Processing efficiency\n    if (clinical.processing_time_seconds > 0) {\n        clinical.quality_efficiency_ratio = metrics.overall_quality_score / clinical.processing_time_seconds;\n    }\n    \n    // Memory usage would be calculated during actual processing\n    clinical.memory_usage_mb = 0.0f;  // Placeholder\n    \n    // Region-specific accuracy (would require atlas registration)\n    // Placeholder values\n    clinical.region_accuracy.frontal_dice = metrics.overlap.dice_coefficient;\n    clinical.region_accuracy.parietal_dice = metrics.overlap.dice_coefficient;\n    clinical.region_accuracy.temporal_dice = metrics.overlap.dice_coefficient;\n    clinical.region_accuracy.occipital_dice = metrics.overlap.dice_coefficient;\n    clinical.region_accuracy.cerebellum_dice = metrics.overlap.dice_coefficient;\n    clinical.region_accuracy.brainstem_dice = metrics.overlap.dice_coefficient;\n    \n    return clinical;\n}
#include \"itkOtsuThresholdImageFilter.h\"
#include \"itkSignedMaurerDistanceMapImageFilter.h\"
#include \"itkStatisticsImageFilter.h\"